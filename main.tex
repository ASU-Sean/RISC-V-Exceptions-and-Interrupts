\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.75in]{geometry}
\usepackage{array}
\usepackage{tabularx}
\usepackage{pifont}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{cite}
\usepackage{listings}
\usepackage{tikz}

\newcommand{\instbit}[1]{\mbox{\scriptsize #1}}
\newcommand{\instbitrange}[2]{~\instbit{#1} \hfill \instbit{#2}~}
\newcolumntype{I}{>{\centering\arraybackslash}p{0.18in}}
\newcolumntype{W}{>{\centering\arraybackslash}p{0.36in}}
\newcolumntype{F}{>{\centering\arraybackslash}p{0.54in}}
\newcolumntype{Y}{>{\centering\arraybackslash}p{0.72in}}
\newcolumntype{R}{>{\centering\arraybackslash}p{0.9in}}
\newcolumntype{S}{>{\centering\arraybackslash}p{1.08in}}
\newcolumntype{O}{>{\centering\arraybackslash}p{1.26in}}
\newcolumntype{E}{>{\centering\arraybackslash}p{1.44in}}
\newcolumntype{T}{>{\centering\arraybackslash}p{1.8in}}
\newcolumntype{M}{>{\centering\arraybackslash}p{2.2in}}
\newcolumntype{K}{>{\centering\arraybackslash}p{2.88in}}
\newcolumntype{U}{>{\centering\arraybackslash}p{3.6in}}
\newcolumntype{L}{>{\centering\arraybackslash}p{3.6in}}
\newcolumntype{J}{>{\centering\arraybackslash}p{4.5in}}


\newcommand{\wiri}{\textbf{WIRI}}
\newcommand{\wpri}{\textbf{WPRI}}
\newcommand{\wlrl}{\textbf{WLRL}}
\newcommand{\warl}{\textbf{WARL}}

\usetikzlibrary{shapes.geometric}
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!30]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=orange!30]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\title{RISC-V Exceptions and Interrupts}
\author{Sean Keller}
\date{October 2020}

\begin{document}

\maketitle
\newpage

\section{Privilege Modes and Control Status Registers}
RISC-V supports three different privilege modes: M-mode (highest priority), S-mode, and U-mode (lowest priority). Currently, hypervisor-mode (H-mode) is reserved and is not a formal part of the RISC-V ISA. RISC-V also supports an optional debug mode (D-mode) for off-chip debugging that can be considered to be an additional privilege mode with more access than M-mode. Code run in machine-mode (M-mode) is usually inherently trusted, as it has low-level access to the machine implementation. M-mode can be used to manage secure execution environments on RISC-V. User-mode (U-mode) and supervisor-mode (S-mode) are intended for conventional application and operating system usage respectively. Privilege-level actions like exception and interrupt handling rely on a set of control and status registers (CSRs). Each privilege mode supports a set of privilege-specific CSRs for the privilege-specific trap handlers. In this document, CSRs or fields in CSRs prefixed with an \emph{x} refer to the possibility that CSRs can have three privilege-specific implementations: M-mode (x = m), S-mode (x = s), and U-mode (x = u). These privilege-specific CSRs are controlled by their respective privilege-specific trap handlers. 

\section{Exceptions and Interrupts}
RISC-V defines exceptions as an unusual condition occurring at run time associated with an instruction in the current hart. Exceptions can be organized into six different categories: fetch, load, store, misaligned jump/branch (i.e misaligned instruction address), illegal instruction, and ECALL/EBREAK. Interrupts refer to an external, asynchronous event that may cause the RISC-V hart to experience an unexpected transfer of control. Interrupts are organized into three different categories: external, software, and timer. External interrupts are raised by devices connected to the processor, software interrupts are raised by programs, and timer interrupts are raised when the value in the {\tt{xtime}} CSR is greater than or equal the value in the {\tt{xtimecmp}} CSR. For multi-hart systems, interrupts also rely on an inter-processor interface (see Section 6) to handle interrupts between multiple harts.

\begin{section}{Exception Handling}
\subsection{M-Mode Exceptions}
If an exception occurs, control is relinquished by the program that is currently being executed and transferred to the trap handler. The trap handler can be thought of as a software function call the program executes in response to an erroneous hardware event. During this function call the program jumps to an address and writes to a set of CSRs before resuming the program at the location that raised the exception. Before an exception can be raised and handled, the trap handler must be initialized. By default, M-mode, S-mode, and U-mode exceptions are handled by the M-mode trap handler. Software initializes the M-mode trap handler by setting the {\tt{mtvec}} CSR (see Figure \ref{mtvecreg} in the Appendix). The {\tt{mtvec}} CSR contains a base address and a mode field. This mode field supports two options: direct and vectored. For both modes, the program counter is set to the base address in {\tt{mtvec}}. This is the address where the M-mode trap handler is located.

Once the program jumps to the M-mode trap handler, the {\tt{mepc}}, {\tt{mstatus}}, {\tt{mtval}}, and {\tt{mcause}} CSRs are set before the program exits the trap handler and resumes execution at the instruction that raised the exception. The {\tt{mepc}} CSR (see Figure \ref{mepcreg} in the Appendix) is written with the virtual address of the instruction that took the trap. This address is stored so that the program can be returned to and resumed after the trap handler is finished. In M-mode, the two-bit MPP field in {\tt{mstatus}} (see Figure \ref{mstatusreg-rv32} in the Appendix) is written with the privilege level encoding corresponds to the privilege level the program was in when the exception was raised. MPP can hold three values: 11 (M-mode), 01 (S-mode), and 00 (U-mode). In addition so setting MPP, the 1-bit MPIE field is set the the value in the 1-bit MIE field before the MIE field is set to zero. These fields in {\tt{mstatus}} do not effect exception handling and are only changed so that trap handler does not process more than one interrupt at a time. The {\tt{mtval}} CSR (see Figure \ref{mtvalreg} in the Appendix) is written with exception-specific information. For EBREAKs, misaligned addresses, access faults, and page faults, {\tt{mtval}} will contain the faulting virtual address. When page-based virtual memory is enabled, {\tt{mtval}} is written with the faulting virtual address, even for physical-memory access exceptions. For illegal instructions, {\tt{mtval}} contains the faulting instruction bits of the illegal instruction i.e the faulting instruction. The {\tt{mcause}} CSR (see Figure \ref{mcausereg} in the Appendix) is written with the exception cause code that corresponds to the exception that was raised. If an instruction raises multiple synchronous exceptions, the exceptions are taken by the trap handler and reported in {\tt{mcause}} according to a pre-defined priority structure. After these CSRs are set, the trap handler executes an MRET instruction to jump back to the address stored in {\tt{mepc}} so that the program can resume. During this time, MRET also sets MIE to the value in MPIE before setting MPIE to one to indicate that the trap handler is ready for the next interrupt. 

\subsection{S-Mode Exceptions}
Exceptions raised in S-mode can be handled in M-mode or delegated to S-mode through the {\tt{medeleg}} CSR (see Figure \ref{medelegreg} in the Appendix). Delegating to S-mode means that only S-mode CSRs are visible in hardware and exceptions are processed by the S-mode trap handler. The {\tt{medeleg}} CSR delegates exceptions by raising the bits in positions that correspond to exception code numbers. This delegation process can be expressed by a single line of Verilog code as shown below.  

\begin{lstlisting}[language=Verilog]
assign dCSR_medeleg = 32'b1 << exception_cause_code; // Set medeleg
\end{lstlisting}

Software initializes the S-mode trap handler by setting the {\tt{stvec}} CSR (see Figure \ref{stvecreg} in the Appendix). The {\tt{stvec}} CSR contains a base address and a mode field. This mode field supports two options: direct and vectored. For both modes, the program counter is set to the base address in {\tt{stvec}}. This is the address where the S-mode trap handler is located. 

Once the program jumps to the S-mode trap handler, the {\tt{sepc}}, {\tt{mstatus}}, {\tt{stval}}, and {\tt{scause}} CSRs are set before the program exits the trap handler and resumes execution at the instruction that raised the exception. The {\tt{sepc}} CSR (see Figure \ref{sepcreg} in the Appendix) is written with the virtual address of the instruction that took the trap. This address is stored so that the program can be returned to and resumed after the trap handler is finished. In S-mode, the two-bit SPP field in {\tt{mstatus}}\footnote[1]{S-mode and U-mode can utilize {\tt{mstatus}} instead of {\tt{sstatus}} and {\tt{ustatus}}. These CSRs simply restrict the higher privilege level fields from being visible to hardware.} is written with the privilege level encoding corresponds to the privilege level the program was in when the exception was raised. SPP can hold two values: 1 (S-mode) or 0 (U-mode). In addition to setting SPP, the 1-bit SPIE field is set the the value in the 1-bit SIE field before the SIE field is set to zero. These fields in {\tt{mstatus}} do not effect exception handling and are only changed so that trap handler does not process more than one interrupt at a time. The {\tt{stval}} CSR (see Figure \ref{stvalreg} in the Appendix) is written with exception-specific information. For EBREAKs, misaligned addresses, access faults, and page faults, {\tt{stval}} will contain the faulting virtual address. When page-based virtual memory is enabled, {\tt{stval}} is written with the faulting virtual address, even for physical-memory access exceptions. For illegal instructions, {\tt{stval}} contains the faulting instruction bits of the illegal instruction i.e the faulting instruction. The {\tt{scause}} CSR (see Figure \ref{scausereg} in the Appendix) is written with the exception cause code that corresponds to the exception that was raised. If an instruction raises multiple synchronous exceptions, the exceptions are taken by the trap handler and reported in {\tt{scause}} according to a pre-defined priority structure. After these CSRs are set, the trap handler executes an SRET instruction to jump back to the address stored in {\tt{sepc}} so that the program can resume. During this time, SRET also sets SIE to the value in SPIE before setting SPIE to one to indicate that the trap handler is ready for the next interrupt.

\subsection{U-Mode Exceptions}
Exceptions raised in U-mode can be handled in M-mode, delegated to S-mode through the {\tt{medeleg}} CSR, or delegated to U-mode through the {\tt{sedeleg}} CSR (see Figure \ref{sedelegreg} in the Appendix). Delegating to U-mode means that only U-mode CSRs are visible in hardware and exceptions are processed by the U-mode trap handler as shown in Figure \ref{delegation}. The {\tt{sedeleg}} CSR delegates exceptions that first must be delegated by the {\tt{medeleg}} CSR by raising the bits in positions that correspond to exception code numbers. This delegation process can be expressed by two lines of Verilog code as shown below.

\begin{lstlisting}[language=Verilog]
assign dCSR_medeleg = 32'b1 << exception_cause_code; // Set medeleg
assign dCSR_sedeleg = 32'b1 << exception_cause_code; // Set sedeleg
\end{lstlisting}

Software initializes the U-mode trap handler by setting the {\tt{utvec}} CSR (see Figure \ref{utvecreg} in the Appendix). The {\tt{utvec}} CSR contains a base address and a mode field. This mode field supports two options: direct and vectored. For both modes, the program counter is set to the base address in {\tt{utvec}}. This is the address where the U-mode trap handler is located.

Once the program jumps to the S-mode trap handler, the {\tt{uepc}}, {\tt{mstatus}}, {\tt{utval}}, and {\tt{ucause}} CSRs are set before the program exits the trap handler and resumes execution at the instruction that raised the exception. The {\tt{uepc}} CSR (see Figure \ref{uepcreg} in the Appendix) is written with the virtual address of the instruction that took the trap. This address is stored so that the program can be returned to and resumed after the trap handler is finished. The {\tt{mstatus}} CSR does not include a UPP field for U-mode since it is implicitly set to zero. However, {\tt{mstatus}} does include 1-bit SPIE and SIE fields where the SPIE field is set the the value in the SIE field before the SIE field is set to zero. These fields in {\tt{mstatus}} do not effect exception handling and are only changed so that trap handler does not process more than one interrupt at a time. The {\tt{utval}} CSR (see Figure \ref{utvalreg} in the Appendix) is written with exception-specific information. For EBREAKs, misaligned addresses, access faults, and page faults, {\tt{utval}} will contain the faulting virtual address. When page-based virtual memory is enabled, {\tt{utval}} is written with the faulting virtual address, even for physical-memory access exceptions. For illegal instructions, {\tt{utval}} contains the faulting instruction bits of the illegal instruction i.e the faulting instruction. The {\tt{ucause}} CSR (see Figure \ref{ucausereg} in the Appendix) is written with the exception cause code that corresponds to the exception that was raised. If an instruction raises multiple synchronous exceptions, the exceptions are taken by the trap handler and reported in {\tt{ucause}} according to a pre-defined priority structure. After these CSRs are set, the trap handler executes an URET instruction to jump back to the address stored in {\tt{uepc}} so that the program can resume. During this time, URET also sets UIE to the value in UPIE before setting UPIE to one to indicate that the trap handler is ready for the next interrupt.
\end{section}

\subsection{Exception Priority}
If an instruction raises multiple synchronous exceptions, the decreasing priority order of Table \ref{exceptionpriorities} indicates which exception is taken. Synchronous exceptions are of lower priority than all interrupts and the priority of any custom synchronous exceptions is implementation-defined. 

\begin{table}
\centering
\begin{tabular}{| l | l | l |}
\hline
Priority & Exception Code & Description \\
\hline
\emph{Highest} & 12 & Instruction Page Fault \\
\hline
& 1 & Instruction Access Fault \\
\hline
& 2 & Illegal Instruction \\ 
\hline
& 0 & Instruction Address Misaligned \\ 
\hline
& 8, 9, 11 & Environment Call (U, S, M) \\
\hline
& 3 & Environment Break \\ 
\hline
& 6 & Store/AMO Address Misaligned \\ 
\hline
& 4 & Load Address Misaligned \\ 
\hline
& 15 & Store/AMO Page Fault \\
\hline
& 13 & Load Page Fault \\
\hline
& 7 & Store/AMO Access Fault \\
\hline
\emph{Lowest} & 5 & Load Access Fault \\ 
\hline
\end{tabular}
\caption{Exception Priorities Priorities}
\label{exceptionpriorities}
\end{table}

\begin{figure}
\centering
\begin{tikzpicture}[node distance=2cm]
\node (start1) [startstop] {Start};
\node (dec1) [decision, below of=start1, yshift =-1cm] {Write {\tt{medeleg}}?};
\node (pro1) [process, below of=dec1, xshift=3.5cm, yshift=-1cm] {Route to M-mode trap handler};
\node (dec2) [decision, below of=dec1, xshift=-3.5cm, yshift=-3cm] {Write {\tt{sedeleg?}}};
\node (pro2) [process, below of=dec2, xshift=5cm, yshift=-0.5cm] {Route to S-mode trap handler};
\node (pro3) [process, below of=dec2, xshift=-5cm, yshift=-0.5cm] {Route to U-mode trap handler};

\draw [arrow] (start1) -- (dec1);
\draw [arrow] (dec1) -| node[anchor=south] {no} (pro1);
\draw [arrow] (dec1) -| node[anchor=south] {yes} (dec2);
\draw [arrow] (dec2) -| node[anchor=south] {no} (pro2);
\draw [arrow] (dec2) -| node[anchor=south] {yes} (pro3);
\end{tikzpicture}
\caption{Flow Chart of Delegation Process}
\label{delegation}
\end{figure}

\section{Exception Definitions}
\subsection{Misaligned Addresses}
Misaligned instruction addresses is a misleading term that refers to misaligned branch and jump targets. The misaligned instruction address should be called misaligned branch/jump target. Misaligned instruction addresses are raised when the target of a jump or branch instruction is not aligned to a 4-byte boundary or an 8-byte boundary. 4-byte alignments are associated with RV32 systems and 8-byte alignments are associated with RV64 systems. 2-byte alignments are also possible for 16-bit instruction implementations but this is a customer instruction encoding that is not a formal part of the RISC-V ISA. Misaligned loads/store addresses are raised when the data the load/store instruction accesses from memory is not aligned to the correct byte offset. In general, a data of size \emph{s} bytes at byte address \emph{A} is aligned if \emph{A} mod \emph{s} = 0.

\subsection{Access Faults}
Instruction, load, and store/AMO access faults are raised from failed physical memory protection checks. Physical memory protection (PMP) checks verify that the instruction is accessed from a valid address in memory by the hardware. Access fault exceptions rely on bits L, X, R, and W in an 8-bit PMP configuration register. Bits X, R, and W encode execute, read, and write privileges respectively. The L-bit indicates that the PMP entry is locked, i.e., writes to the configuration register (see Figure \ref{pmpcfg} in the Appendix) and associated address registers are ignored. In addition to locking the PMP entry, the L bit indicates whether the R/W/X permissions are enforced on M-mode accesses. When the L bit is set, these permissions are enforced for all privilege modes. When the L bit is clear, any M-mode access matching the PMP entry will succeed and the R/W/X permissions only apply to S and U modes. Access fault exceptions can only be raised if the L-bit is set or the access is in S-mode or U-mode. Attempting to fetch an instruction whose physical address lies in a PMP region that does not have execute permissions (X = 0) raises a fetch access exception. Attempting to execute a load or load-reserved instruction whose physical address lies within a PMP region without read permissions (R = 0) raises a load access exception. Attempting to execute a store, store-conditional (regardless of success), or AMO instruction whose physical address lies within a PMP region without write permissions (W = 0) raises a store access exception.

\subsection{Illegal Instructions}
Illegal instructions are raised by illegal instruction encodings or problems reading from and writing to certain CSRs. The following is a non-exhaustive list of illegal instructions that could be raised:
\begin{itemize}
    \item Instructions with bits [15:0] set to zero, this is a reserved bit pattern
    \item Instructions with bits [ILEN-1:0]\footnote[2]{ILEN is the maximum length of the maximum instruction length supported by an implementation. For RISC-V, ILEN is typically 32 or 64 bits.} set to one, this a reserved bit pattern 
    \item Bit patterns that the processor does not recognize (ex. multiply or divide)
    \item Instructions that set rd = x0 with the exception of CSRRW, CSRRWI, JALR, and JAL
    \item Attempts to write to a read-only CSR 
    \item Attempts to access CSRs from non-exsistent CSR addresses
    \item Attempts to access a CSR without appropriate privilege level permissions 
    \item Machine-mode access of debug-mode CSRs
    \item Attempts to read or write the {\tt{satp}} CSR or execute the SFENCE.VMA instruction while executing in S-mode when the TVM bit in the {\tt{xstatus}} CSR equals one
    \item Attempts to execute the WFI privilege instruction in any less-privileged mode, and it does not complete within an implementation-specific, bounded time limit\footnote[3]{The time limit may \underline{always} be zero, in which case WFI always causes an illegal instruction exception in less-privileged modes when TW equals one} when the TW bit in the {\tt{mstatus}} CSR equals one
    \item Attempts to execute SRET while executing in S-mode when the TSR bit in the {\tt{xstatus}} register equals one
    \item Any instruction that attempts to read or write when the corresponding XS[1:0] field in the {\tt{xstatus}} CSR is set to zero
    \item Attempts to read to the counter registers that correspond to the IR, TM, and CY bits in the {\tt{mcounteren}} CSR when executing in a less-privileged mode 
\end{itemize}

\subsection{Environment Call and Environment Break}
The environment call instruction (ECALL) is used to make a request to the supporting execution environment. When executed in U-mode, S-mode, or M-mode, it generates an environment-call-from-U-mode exception, environment-call-from-S-mode exception, or environment-call-from-M-mode exception, respectively, and performs no other operation. Similarly, the environment break instruction (EBREAK) raises an exception as part of the instruction execution.

\subsection{Page Faults}
For RV32 systems, the supervisor has a 32-bit, page-based virtual memory system called Sv32. RISC-V identifies three different types of page faults: instruction, load, and store/AMO. Instruction page faults are raised by attempting to fetch an instruction from a page that does not have execute permissions. Load page faults are raised by load or load-reserved instructions whose address lies within a page without read permissions. Store/AMO page faults are raised by store, store-conditional, or AMO instruction whose effective address lies within a page without write permissions. In other words, all instructions can raise instruction page faults, load instructions can only raise load page faults, and store instruction can only raise store page faults. This means that load and store page faults also raise instruction page faults. 

The following lists a number of error that can raise a page fault exception that corresponds to the original access type (instruction, load, and store) during the Sv32 virtual to physical address translation process:
\begin{itemize}
    \item The physical address of the page is insufficiently aligned
    \item PTE bit V = 0, or PTE bit R = 0 and PTE bit W = 1
    \item R, W, and X are zero when the page walk is on level two
    \item Accessing a page in U-mode when the PTE bit U != 1
    \item Attempting to execute S-mode code on page where the PTE bit U = 1
    \item Attempting to execute loads from pages where R = 0 and X = 0 for MXR = 1 in {\tt{mstatus}}
    \item S-mode accesses of pages that are accessible in U-mode (U = 1) when the SUM field in {\tt{mstatus}} is cleared
    \item PTE bit A = 0, or if the memory access is a store and PTE bit D = 0
\end{itemize}

\section{Exception Table}
The exceptions in Table \ref{exceptiontable} fall under the following categories fetch, load, store, misaligned branch/jump, rd != x0 illegal instruction, and ECALL/EBREAK. Fetch exceptions encompass instruction access faults and instruction page faults. Load exceptions encompass misaligned load addresses, load access faults, and load page faults. Store exceptions encompass misaligned store addresses, store access faults, and store page faults. Unless otherwise specified, the fetch, store, and load categories encompass all the respective exceptions included in each category. Misaligned branch/jump exceptions are raised by jump and branch instructions according to the definition for misaligned instruction addresses. EBREAK/ECALL exceptions are raised according to the definitions of environment call and environment break.

\begin{table}
\centering
\begin{tabular}{| c || c | c | c | c | c | c |} 
\hline
Instruction & Fetch & Load & Store & Misaligned Branch/Jump & rd != x0 & ECALL/EBREAK \\
\hline
LUI & \ding{53} & & & & \ding{53} & \\
\hline
AUIPC & \ding{53} & & & & \ding{53} & \\
\hline
JAL & \ding{53} & & & \ding{53} & & \\
\hline
JALR & \ding{53} & & & \ding{53} & & \\
\hline
BEQ & \ding{53} & & & \ding{53} & & \\
\hline
BNE & \ding{53} & & & \ding{53} & & \\
\hline
BLT & \ding{53} & & & \ding{53} & & \\
\hline
BGE & \ding{53} & & & \ding{53} & & \\
\hline
BLTU & \ding{53} & & & \ding{53} & & \\
\hline
BGEU & \ding{53} & & & \ding{53} & & \\
\hline
LB & \ding{53} & \ding{53} & & & \ding{53} & \\
\hline
LH & \ding{53} & \ding{53} & & & \ding{53} & \\
\hline
LW & \ding{53} & \ding{53} & & & \ding{53} & \\
\hline
LBU & \ding{53} & \ding{53} & & & \ding{53} & \\
\hline
LHU & \ding{53} & \ding{53} & & & \ding{53} & \\
\hline
SB & \ding{53} & & \ding{53} & & & \\
\hline
SH & \ding{53} & & \ding{53} & & & \\
\hline
SW & \ding{53} & & \ding{53} & & & \\
\hline
ADDI & \ding{53} & & & & \ding{53} & \\
\hline
SLTI & \ding{53} & & & & \ding{53} & \\
\hline
SLTIU & \ding{53} & & & & \ding{53} & \\
\hline
XORI & \ding{53} & & & & \ding{53} & \\
\hline
ORI & \ding{53} & & & & \ding{53} & \\
\hline
ANDI & \ding{53} & & & & \ding{53} & \\
\hline
SLLI & \ding{53} & & & & \ding{53} & \\
\hline
SRLI & \ding{53} & & & & \ding{53} & \\
\hline
SRAI & \ding{53} & & & & \ding{53} & \\
\hline
ADD & \ding{53} & & & & \ding{53} & \\
\hline
SUB & \ding{53} & & & & \ding{53} & \\
\hline
SLL & \ding{53} & & & & \ding{53} & \\
\hline
SLT & \ding{53} & & & & \ding{53} & \\
\hline
SLTU & \ding{53} & & & & \ding{53} & \\
\hline
XOR & \ding{53} & & & & \ding{53} & \\
\hline
SRL & \ding{53} & & & & \ding{53} & \\
\hline
SRA & \ding{53} & & & & \ding{53} & \\
\hline
OR & \ding{53} & & & & \ding{53} & \\
\hline
AND & \ding{53} & & & & \ding{53} & \\
\hline
ECALL & \ding{53} & & & & & \ding{53} \\
\hline
EBREAK & \ding{53} & & & & & \ding{53} \\
\hline
\end{tabular}
\caption{Possible Exceptions for the RV32I Instruction Set}
\label{exceptiontable}
\end{table}

\begin{figure}
    \centering
    \includegraphics[scale=0.8]{PLIC and CLINT Block Diagram.JPG}
    \caption{Block diagram of an example PLIC and CLINT configuration}
    \label{PLIC_CLINT}
    \vspace{50pt}
    \includegraphics[scale=0.8]{PLIC and CLIC Block Diagram.JPG}
    \caption{Block diagram of an example PLIC and CLIC configuration}
    \label{PLIC_CLIC}
\end{figure}

\section{Interrupt Handling}
\subsection{PLIC, CLINT, and CLIC}
Interrupt handling is similar to exception handling but there are some notable differences. Unlike exceptions, interrupts require additional hardware. This additional hardware includes a RISC-V Platform Level Interrupt Controller (PLIC)\cite{PLIC} and the option of a SiFive Core-local Interrupter (CLINT)\cite{CLINT} or a RISC-V Core-local Interrupt Controller (CLIC)\cite{CLIC}. The PLIC sources external interrupts from devices and routes them to the hart(s) as shown in Figure \ref{PLIC_CLINT}. Similarly, the CLINT sources local software and timer interrupts and routes them to the hart(s). Unlike the CLINT, the CLIC routes external, software, and timer interrupt signals to the hart(s) as shown in Figure \ref{PLIC_CLIC}. RISC-V has defined detailed CLIC and PLIC specifications that explain the interrupt control flow and define the different registers that are used to handle interrupts. For systems with multiple harts, the Wait for Interrupt (WFI) instruction can be implemented to control interrupt servicing between multiple harts by stalling a hart. If an enabled interrupt is present or later becomes present while the hart is stalled, the interrupt exception will be taken on the following instruction.

\subsection{M-Mode Interrupts}
If an interrupt occurs, control is relinquished by the program that is currently being executed and transferred to the trap handler. Before an interrupt can be raised and handled, the trap handler must be initialized and the interrupts must be enabled. By default, M-mode, S-mode, and U-mode interrupts are handled by the M-mode trap handler. Software initializes the M-mode trap handler by setting the {\tt{mtvec}} CSR. The {\tt{mtvec}} CSR contains a base address and a mode field. This mode field supports two options: direct and vectored. In direct mode, the program counter is set to the base address in {\tt{mtvec}}. For vectored mode, the program counter is set to the base address plus four times the interrupt cause code as shown in Table \ref{interruptvectors}\footnote[4]{When vectored interrupts are enabled, interrupt cause 0, which corresponds to user-mode software interrupts, are vectored to the same location as synchronous exceptions. This ambiguity does not arise in practice, since user-mode software interrupts are either disabled or delegated to a less-privileged mode.}. In both cases, these are the address where the M-mode trap handler can be located. Interrupts are said to be enabled if they are enabled by the {\tt{mie}} (see Figure \ref{miereg} in the Appendix) and {\tt{mstatus}} CSRs. External interrupts in M-mode, S-mode, and U-mode are enabled by raising the 1-bit MEIE, SEIE, and UEIE fields in {\tt{mie}} respectively. Timer interrupts in M-mode, S-mode, and U-mode are enabled by raising the 1-bit MTIE, STIE, and UTIE fields in {\tt{mie}} respectively. Software interrupts in M-mode, S-mode, and U-mode are enabled by raising the 1-bit MSIE, SSIE, and USIE fields in {\tt{mie}} respectively. In addition to being enabled by raising bits in {\tt{mie}}, M-mode, S-mode, and U-mode interrupts can also be globally enabled. M-mode interrupts are globally enabled if the current privilege mode is less than M or the current privilege mode is M and the 1-bit MIE field in {\tt{mstatus}} is set. S-mode interrupts are globally enabled if the current privilege mode is less the S or the current privilege mode is S and the 1-bit SIE field in {\tt{mstatus}} is set. U-mode interrupts are globally enabled if the current privilege mode is U and the 1-bit UPP field in {\tt{mstatus}} is set.

The interrupt controllers are responsible for identifying pending interrupts that are received by the hart(s). M-mode external, software, and timer interrupts are raised by setting the 1-bit MEIP, MSIP, and MTIP fields in the {\tt{mip}} CSR (see Figure \ref{mipreg} in the Appendix) respectively. S-mode external, software, and timer interrupts are raised by setting the 1-bit SEIP, SSIP, and STIP fields in the {\tt{mip}} register respectively. U-mode external, software, and timer interrupts are raised by setting the 1-bit UEIP, USIP, and UTIP fields in the {\tt{mip}} register respectively. Raising an interrupt causes the M-mode trap handler to take control of the program. Interrupts processed by the M-mode trap handler are processed in the same manner as exceptions as specified in Section 3.1. The only difference is that interrupts do not set {\tt{mtval}} and it is therefore left cleared. 

\begin{table}
\centering
\begin{tabular}{| l | l |}
\hline
Interrupt & BASE + $4*cause$ \\
\hline
User Software Interrupt & BASE \\
\hline
Supervisor Software Interrupt & BASE + 0x4 \\
\hline
\emph{Reserved} & BASE + 0x8 \\ 
\hline
Machine Software Interrupt & BASE + 0xC \\ 
\hline
User Timer Interrupt & BASE + 0x10 \\
\hline
Supervisor Timer Interrupt & BASE + 0x14 \\ 
\hline
\emph{Reserved} & BASE + 0x18 \\ 
\hline
Machine Timer Interrupt & BASE + 0x1C \\ 
\hline
User External Interrupt & BASE + 0x20 \\ 
\hline
Supervisor External Interrupt & BASE + 0x24 \\ 
\hline
\emph{Reserved} & BASE + 0x28 \\ 
\hline
Machine External Interrupt & BASE + 0x2C \\ 
\hline
\end{tabular}
\caption{Interrupt Vector Table}
\label{interruptvectors}
\end{table}

\subsection{S-Mode Interrupts}
Interrupts raised in S-mode can be handled in M-mode or delegated to S-mode through the {\tt{mideleg}} CSR. Delegating to S-mode means that only S-mode CSRs are visible in hardware and interrupts are processed by the S-mode trap handler. The S-mode trap handler can process S-mode and U-mode interrupts. Software initializes the S-mode trap handler by setting the {\tt{stvec}} CSR. The {\tt{stvec}} CSR contains a base address and a mode field. This mode field supports two options: direct and vectored. In direct mode, the program counter is set to the base address in {\tt{stvec}}. For vectored mode, the program counter is set to the base address plus four times the interrupt cause code. In both cases, these are the address where the S-mode trap handler can be located. Interrupts are said to be enabled if they are enabled by the {\tt{mie}}\footnote[5]{S-mode and U-mode can utilize {\tt{mie}} instead of {\tt{sie}} and {\tt{uie}}. These CSRs simply restrict the higher privilege level fields from being visible to hardware. This also holds true for {\tt{mie}} relative to {\tt{sie}} and {\tt{uie}}.} and {\tt{mstatus}} CSRs. External interrupts in S-mode and U-mode are enabled by raising the 1-bit SEIE and UEIE fields in {\tt{mie}} respectively. Timer interrupts in S-mode and U-mode are enabled by raising the 1-bit STIE and UTIE fields in {\tt{mie}} respectively. Software interrupts in S-mode and U-mode are enabled by raising the 1-bit SSIE and USIE fields in {\tt{mie}} respectively. In addition to being enabled by raising bits in {\tt{mie}}, S-mode and U-mode interrupts can also be globally enabled. S-mode interrupts are globally enabled if the current privilege mode is less the S or the current privilege mode is S and the 1-bit SIE field in {\tt{mstatus}} is set. U-mode interrupts are globally enabled if the current privilege mode is U and the 1-bit UPP field in {\tt{mstatus}} is set.

The interrupt controllers are responsible for identifying pending interrupts that are received by the hart(s). S-mode external, software, and timer interrupts are raised by setting the 1-bit SEIP, SSIP, and STIP fields in the {\tt{mip}} CSR respectively. U-mode external, software, and timer interrupts are raised by setting the 1-bit UEIP, USIP, and UTIP fields in the {\tt{mip}} register respectively. Raising an interrupt causes the S-mode trap handler to take control of the program. Interrupts processed by the S-mode trap handler are processed in the same manner as exceptions as specified in Section 3.2. The only difference is that interrupts do not set {\tt{stval}} and it is therefore left cleared. 

\subsection{U-Mode Interrupts}
Interrupts raised in U-mode can be handled in M-mode, delegated to S-mode through the {\tt{mideleg}} CSR, or delegated to U-mode through the \emph{sideleg} CSR. Delegating to U-mode means that only U-mode CSRs are visible in hardware and interrupts are processed by the U-mode trap handler. The U-mode trap handler can only process U-mode interrupts. Software initializes the U-mode trap handler by setting the {\tt{utvec}} CSR. The {\tt{utvec}} CSR contains a base address and a mode field. This mode field supports two options: direct and vectored. In direct mode, the program counter is set to the base address in {\tt{utvec}}. For vectored mode, the program counter is set to the base address plus four times the interrupt cause code. In both cases, these are the address where the U-mode trap handler can be located. Interrupts are said to be enabled if they are enabled by the {\tt{mie}} and {\tt{mstatus}} CSRs. External interrupts U-mode are enabled by raising the 1-bit UEIE field in {\tt{mie}}. Timer interrupts in U-mode are enabled by raising the 1-bit UTIE field in {\tt{mie}}. Software interrupts in U-mode are enabled by raising the 1-bit USIE field in {\tt{mie}}. In addition to being enabled by raising bits in {\tt{mie}}, U-mode interrupts can also be globally enabled. U-mode interrupts are globally enabled if the current privilege mode is U and the 1-bit UPP field in {\tt{mstatus}} is set.

The interrupt controllers are responsible for identifying pending interrupts that are received by the hart(s). U-mode external, software, and timer interrupts are raised by setting the 1-bit UEIP, USIP, and UTIP fields in the {\tt{mip}} CSR respectively. Raising an interrupt causes the U-mode trap handler to take control of the program. Interrupts processed by the U-mode trap handler are processed in the same manner as exceptions as specified in Section 3.3. The only difference is that interrupts do not set {\tt{utval}} and it is therefore left cleared.

\subsection{Interrupt Priority}
Like exception, simultaneous interrupts are processed by the trap handler according to a fixed priority structure as show in Table \ref{interruptpriorities}. The exception codes for interrupts are differentiated from the exception codes for exceptions with a 1-bit interrupt field in the MSB of {\tt{xcause}}. Raising this field indicates that the exception code in {\tt{xcause}} is for an interrupt. 

\begin{table}
\centering
\begin{tabular}{| l | l | l |}
\hline
Priority & Exception Code & Description \\
\hline
\emph{Highest} & 11 & Machine External Interrupt \\
\hline
& 3 & Machine Software Interrupt \\
\hline
& 7 & Machine Timer Interrupt \\ 
\hline
& 9 & Supervisor External Interrupt \\ 
\hline
& 1 & Supervisor Software Interrupt \\
\hline
& 5 & Supervisor Timer Interrupt \\ 
\hline
& 8 & User External Interrupt \\ 
\hline
& 0 & User Software Interrupt \\ 
\hline
\emph{Lowest} & 4 & User Timer Interrupt \\ 
\hline
\end{tabular}
\caption{Interrupt Priorities}
\label{interruptpriorities}
\end{table}

\clearpage

\section{CSR Appendix}

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{J@{}S}
\instbitrange{MXLEN-1}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{BASE[MXLEN-1:2] (\warl)} & 
\multicolumn{1}{c|}{MODE (\warl)} \\
\hline
MXLEN-2 & 2 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine trap-vector base-address register ({\tt mtvec}).}
\label{mtvecreg}
\end{figure*}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{MXLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt mepc} \\
\hline
MXLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine exception program counter register.}
\label{mepcreg}
\end{figure}

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{cKccccccc}
\\
\instbit{31} &
\instbitrange{30}{23} &
\instbit{22} &
\instbit{21} &
\instbit{20} &
\instbit{19} &
\instbit{18} &
\instbit{17} &
 \\
\hline
\multicolumn{1}{|c|}{SD} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{TSR} &
\multicolumn{1}{c|}{TW} &
\multicolumn{1}{c|}{TVM} &
\multicolumn{1}{c|}{MXR} &
\multicolumn{1}{c|}{SUM} &
\multicolumn{1}{c|}{MPRV} &
 \\
\hline
1 & 8 & 1 & 1 & 1 & 1 & 1 & 1 & \\
\end{tabular}
\begin{tabular}{cWWcWccccccccc}
\\
&
\instbitrange{16}{15} &
\instbitrange{14}{13} &
\instbitrange{12}{11} &
\instbitrange{10}{9} &
\instbit{8} &
\instbit{7} &
\instbit{6} &
\instbit{5} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
 &
\multicolumn{1}{|c|}{XS[1:0]} &
\multicolumn{1}{c|}{FS[1:0]} &
\multicolumn{1}{c|}{MPP[1:0]} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPP} &
\multicolumn{1}{c|}{MPIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPIE} &
\multicolumn{1}{c|}{UPIE} &
\multicolumn{1}{c|}{MIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SIE} &
\multicolumn{1}{c|}{UIE} \\
\hline
 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine-mode status register ({\tt mstatus}) for RV32.}
\label{mstatusreg-rv32}
\end{figure*}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{MXLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt mtval} \\
\hline
MXLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine Trap Value register.}
\label{mtvalreg}
\end{figure}

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{c@{}U}
\instbit{MXLEN-1} &
\instbitrange{MXLEN-2}{0} \\
\hline
\multicolumn{1}{|c|}{Interrupt} &
\multicolumn{1}{c|}{Exception Code (\wlrl)} \\
\hline
1 & MXLEN-1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine Cause register {\tt mcause}.}
\label{mcausereg}
\end{figure*}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}U}
\instbitrange{MXLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{Synchronous Exceptions (\warl)} \\
\hline
MXLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine Exception Delegation Register {\tt medeleg}.}
\label{medelegreg}
\end{figure}

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{J@{}R}
\instbitrange{SXLEN-1}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{BASE[SXLEN-1:2] (\warl)} & 
\multicolumn{1}{c|}{MODE (\warl)} \\
\hline
SXLEN-2 & 2 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Supervisor trap vector base address register ({\tt stvec}).}
\label{stvecreg}
\end{figure*}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{SXLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt sepc} \\
\hline
SXLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Supervisor exception program counter register.}
\label{sepcreg}
\end{figure}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{SXLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt stval} \\
\hline
SXLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Supervisor Trap Value register.}
\label{stvalreg}
\end{figure}

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{c@{}U}
\instbit{SXLEN-1} &
\instbitrange{SXLEN-2}{0} \\
\hline
\multicolumn{1}{|c|}{Interrupt} &
\multicolumn{1}{c|}{Exception Code (\wlrl)} \\
\hline
1 & SXLEN-1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Supervisor Cause register {\tt scause}.}
\label{scausereg}
\end{figure*}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}U}
\instbitrange{SXLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{Synchronous Exceptions (\warl)} \\
\hline
SXLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Supervisor Exception Delegation Register {\tt sedeleg}.}
\label{sedelegreg}
\end{figure}

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{J@{}R}
\instbitrange{UXLEN-1}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{BASE[UXLEN-1:2] (\warl)} & 
\multicolumn{1}{c|}{MODE (\warl)} \\
\hline
UXLEN-2 & 2 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{User trap vector base address register ({\tt utvec}).}
\label{utvecreg}
\end{figure*}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{UXLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt uepc} \\
\hline
UXLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{User exception program counter register.}
\label{uepcreg}
\end{figure}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{UXLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt utval} \\
\hline
UXLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{User Trap Value register.}
\label{utvalreg}
\end{figure}

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{c@{}U}
\instbit{UXLEN-1} &
\instbitrange{UXLEN-2}{0} \\
\hline
\multicolumn{1}{|c|}{Interrupt} &
\multicolumn{1}{c|}{Exception Code (\wlrl)} \\
\hline
1 & UXLEN-1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{User Cause register {\tt ucause}.}
\label{ucausereg}
\end{figure*}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{YSSYYY}
\instbit{7} &
\instbitrange{6}{5} &
\instbitrange{4}{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{L (\warl)} &
\multicolumn{1}{c|}{0 (\warl)} &
\multicolumn{1}{c|}{A (\warl)} &
\multicolumn{1}{c|}{X (\warl)} &
\multicolumn{1}{c|}{W (\warl)} &
\multicolumn{1}{c|}{R (\warl)}
\\
\hline
1 & 2 & 2 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{PMP configuration register format.}
\label{pmpcfg}
\end{figure}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}U}
\instbitrange{MXLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{Interrupts (\warl)} \\
\hline
MXLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine Interrupt-Enable Register ({\tt mie}).}
\label{miereg}
\end{figure}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}U}
\instbitrange{MXLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{Interrupts (\warl)} \\
\hline
MXLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine Interrupt-Pending Register ({\tt mip}).}
\label{mipreg}
\end{figure}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}U}
\instbitrange{MXLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{Interrupts (\warl)} \\
\hline
MXLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine Interrupt Delegation Register {\tt mideleg}.}
\label{midelegreg}
\end{figure}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}U}
\instbitrange{SXLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{Interrupts (\warl)} \\
\hline
SXLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Supervisor Interrupt Delegation Register {\tt sideleg}.}
\label{sidelegreg}
\end{figure}

\clearpage

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,bibliography}
\end{document}
